import unittest
import threading
import unity_python.common.scheduling as scheduling

class TestScheduling(unittest.TestCase):
    def setUp(self):
        self._x = 0
        if hasattr(self,'_magic'):
            self._magic += 1
        else:
            self._magic = 17

    def assert_run_on_main(self):
        self.assertTrue(threading.current_thread() is threading.main_thread())
        self._x = self._magic

    @scheduling.exec_on_main_thread
    def run_on_main(self):
        self.assert_run_on_main()

    @scheduling.exec_on_main_thread_async
    def run_on_main_async(self):
        self.assert_run_on_main()

    # Test main thread, running in main thread => run immediately.
    def test_run_on_main(self):
        self.run_on_main()
        self.assertTrue(self._x == self._magic)

    # Test main thread, running in main thread async => queue
    def test_run_on_main_async(self):
        # async => doesn't happen right away
        self.run_on_main_async()
        self.assertTrue(self._x == 0)
        self.assertFalse(scheduling._jobs.empty())

        # process the queue
        scheduling.process_all_jobs()

        # now it happened!
        self.assertTrue(scheduling._jobs.empty())
        self.assertTrue(self._x == self._magic)

    # Test side thread, running in main thread => block until we run the queue
    def test_run_on_thread(self):
        t = threading.Thread(target = self.run_on_main)
        t.start()

        # wait for t to post the job
        job = scheduling._jobs.get(timeout=1)
        scheduling._jobs.put(job)

        # t posted the job but it hasn't run yet
        self.assertTrue(self._x == 0)

        # try to join; this will fail => t is blocked waiting on the job
        t.join(timeout=1)
        self.assertTrue(t.is_alive())

        # process the job => verify it ran
        scheduling.process_all_jobs()
        self.assertTrue(self._x == self._magic)

        # t will soon quit 
        t.join(timeout=1)
        self.assertFalse(t.is_alive())

    # Test side thread, running in main thread async => quit immediately
    def test_run_on_thread_async(self):
        t = threading.Thread(target = self.run_on_main_async)
        t.start()

        # wait for t to post the job
        job = scheduling._jobs.get(timeout=1)
        scheduling._jobs.put(job)

        # t posted the job but the job hasn't run yet
        self.assertTrue(self._x == 0)

        # try to join; this will succeed => t posted the job and quit
        t.join(timeout=1)
        self.assertFalse(t.is_alive())

        # process the job => verify it ran
        scheduling.process_all_jobs()
        self.assertTrue(self._x == self._magic)

if __name__ == '__main__':
    unittest.main()
